using System;
using System.Text;
using System.Collections.Generic;
using System.ComponentModel;
using System.ServiceModel;
using System.ServiceModel.Activation;
using System.ServiceModel.Description;
using System.ServiceModel.Web;
using System.Runtime.Serialization;
using System.Reflection;
using System.Reflection.Emit;
using System.CodeDom;
using System.CodeDom.Compiler;
using Microsoft.CSharp;
using Microsoft.VisualBasic;
using System.IO;

namespace Feng.Server.Utils
{
    public static class TypeHelper
    {
        public static void GenerateCodeFromType(Type srcType, string fileName = null, string namespaceName = null)
        {
            if (string.IsNullOrEmpty(namespaceName))
                namespaceName = "Feng.AutoGenerated";
            if (string.IsNullOrEmpty(fileName))
                fileName = ".\\GeneratedCode\\Type_" + srcType.Name;
            var codeCompileUnit = GenerateCodeCompileUnitFromType(srcType, namespaceName);
            GenerateCode(codeCompileUnit, fileName);
        }
        private static CodeCompileUnit GenerateCodeCompileUnitFromType(Type srcType, string namespaceName)
        {
            CodeCompileUnit compileUnit = new CodeCompileUnit();
            // Create a NameSpace - "namespace CodeDomSampleNS"
            CodeNamespace codedomsamplenamespace = new CodeNamespace(namespaceName);
            // Create using statement - "using System;"
            codedomsamplenamespace.Imports.Add(new CodeNamespaceImport("System"));
            codedomsamplenamespace.Imports.Add(new CodeNamespaceImport("System.Runtime.Serialization"));

            // Create a type inside the namespace - public class CodeDomSample
            CodeTypeDeclaration classType = new CodeTypeDeclaration("Type_" + srcType.Name);
            classType.IsClass = true;
            classType.Attributes = MemberAttributes.Public;
            classType.BaseTypes.Add(new CodeTypeReference("Feng.IEntity"));
            classType.CustomAttributes.Add(new CodeAttributeDeclaration("DataContract",
                new CodeAttributeArgument("Name", new CodePrimitiveExpression(srcType.Name))));

            int idx = 0;
            // Loop over the attributes that will be used as the properties names in out new type
            foreach (PropertyInfo propertyInfo in srcType.GetProperties())
            {
                string propertyName = propertyInfo.Name;
                Type propertyType = propertyInfo.PropertyType;

                bool supportedType = false;

                if (propertyType.IsValueType)
                {
                    if (propertyType.IsEnum)
                    {
                        propertyType = propertyType.GetEnumUnderlyingType();
                    }
                    supportedType = true;
                }
                else if (propertyType == typeof(string))
                {
                    supportedType = true;
                }
                //else if (propertyType.IsSubclassOf(typeof(System.Collections.IEnumerable)))
                //{
                //}
                else if (propertyType.GetInterface("IEnumerable") != null)  // Collections
                {
                }
                else
                {
                    propertyType = typeof(string);
                    supportedType = true;
                }
                if (!supportedType)
                    continue;

                string fieldName = "_" + propertyName;
                var field = new CodeMemberField()
                {
                    Name = fieldName,
                    Type = new CodeTypeReference(propertyType),
                    Attributes = MemberAttributes.Private
                };
                classType.Members.Add(field);

                CodeMemberProperty p = new CodeMemberProperty();
                p.Name = propertyName;
                p.Type = new CodeTypeReference(propertyType);
                p.Attributes = MemberAttributes.Public;
                p.HasGet = true;
                p.HasSet = true;
                p.CustomAttributes.Add(new CodeAttributeDeclaration("DataMember",
                    new CodeAttributeArgument("Name", new CodePrimitiveExpression(propertyName)),
                    new CodeAttributeArgument("Order", new CodePrimitiveExpression(idx))));

                p.GetStatements.Add(new CodeMethodReturnStatement(new CodeFieldReferenceExpression(
                        new CodeThisReferenceExpression(), fieldName)));
                p.SetStatements.Add(new CodeAssignStatement(new CodeFieldReferenceExpression(
                            new CodeThisReferenceExpression(), fieldName),
                            new CodePropertySetValueReferenceExpression()));

                classType.Members.Add(p);

                idx++;
            }

            // Add the type to the namespace
            codedomsamplenamespace.Types.Add(classType);

            // Add the NameSpace to the CodeCompileUnit
            compileUnit.Namespaces.Add(codedomsamplenamespace);

            return compileUnit;
        }

        public static void GenerateCodeFromWintabInfo(string wintabName, string fileName = null, string namespaceName = null)
        {
            if (string.IsNullOrEmpty(namespaceName))
                namespaceName = "Feng.AutoGenerated";
            if (string.IsNullOrEmpty(fileName))
                fileName = ".\\GeneratedCode\\WinTab_" + wintabName;
            var codeCompileUnit = GenerateCodeCompileUnitFromWintabInfo(wintabName, namespaceName);
            GenerateCode(codeCompileUnit, fileName);
        }

        private static CodeCompileUnit GenerateCodeCompileUnitFromWintabInfo(string wintabName, string namespaceName)
        {
            var tabInfo = ADInfoBll.Instance.GetWindowTabInfo(wintabName);
            if (tabInfo == null)
            {
                throw new ArgumentException(string.Format("There is no wintab of {0}", wintabName));
            }
            var gridColumnInfos = ADInfoBll.Instance.GetGridColumnInfos(tabInfo.GridName);

            CodeCompileUnit compileUnit = new CodeCompileUnit();
            // Create a NameSpace - "namespace CodeDomSampleNS"
            CodeNamespace codedomsamplenamespace = new CodeNamespace(namespaceName);
            // Create using statement - "using System;"
            codedomsamplenamespace.Imports.Add(new CodeNamespaceImport("System"));
            codedomsamplenamespace.Imports.Add(new CodeNamespaceImport("System.Runtime.Serialization"));

            // Create a type inside the namespace - public class CodeDomSample
            CodeTypeDeclaration classType = new CodeTypeDeclaration("WinTab_" + wintabName);
            classType.IsClass = true;
            classType.Attributes = MemberAttributes.Public;
            classType.BaseTypes.Add(new CodeTypeReference("Feng.IEntity"));
            classType.CustomAttributes.Add(new CodeAttributeDeclaration("DataContract",
                new CodeAttributeArgument("Name", new CodePrimitiveExpression(wintabName))));

            //// Create a Main method which will be entry point for the class
            //// public static void Main
            //CodeEntryPointMethod mainmethod = new CodeEntryPointMethod();
            //// Add an expression inside Main -
            ////  Console.WriteLine("Inside Main ...");
            //CodeMethodInvokeExpression mainexp1 = new CodeMethodInvokeExpression(
            //    new CodeTypeReferenceExpression("System.Console"),
            //    "WriteLine", new CodePrimitiveExpression("Inside Main ..."));
            //mainmethod.Statements.Add(mainexp1);
            //// Add another expression inside Main
            ////  CodeDomSample cs = new CodeDomSample()
            //CodeStatement cs = new CodeVariableDeclarationStatement(typeof(CodeDomSample), "cs", new CodeObjectCreateExpression(new CodeTypeReference(typeof(CodeDomSample))));
            //mainmethod.Statements.Add(cs);


            //// Create a constructor for the CodeDomSample class
            //// public CodeDomSample() { }
            ////
            //CodeConstructor constructor = new CodeConstructor();
            //constructor.Attributes = MemberAttributes.Public;
            //// Add an expression to the constructor
            //// public CodeDomSample() { Comsole.WriteLine("Inside CodeDomSample Constructor ...");
            //CodeMethodInvokeExpression constructorexp = new CodeMethodInvokeExpression(new CodeTypeReferenceExpression("System.Console"), "WriteLine", new CodePrimitiveExpression("Inside CodeDomSample Constructor ..."));
            //constructor.Statements.Add(constructorexp);
            // Add constructor and mainmethod to type
            //newType.Members.Add(constructor);
            //newType.Members.Add(mainmethod);

            int idx = 0;
            // Loop over the attributes that will be used as the properties names in out new type
            foreach (GridColumnInfo info in gridColumnInfos)
            {
                if (info.GridColumnType != GridColumnType.Normal
                    && info.GridColumnType != GridColumnType.ExpressionColumn)
                    continue;

                string propertyName = info.GridColumnName;
                propertyName = Feng.Utils.StringHelper.NormalizePropertyName(propertyName);
                string fieldName = "_" + propertyName;
                var field = new CodeMemberField()
                {
                    Name = fieldName,
                    Type = new CodeTypeReference(typeof(string)),
                    Attributes = MemberAttributes.Private
                };
                classType.Members.Add(field);

                CodeMemberProperty p = new CodeMemberProperty();
                p.Name = propertyName;
                p.Type = new CodeTypeReference(typeof(string));
                p.Attributes = MemberAttributes.Public;
                p.HasGet = true;
                p.HasSet = true;
                p.CustomAttributes.Add(new CodeAttributeDeclaration("DataMember",
                    new CodeAttributeArgument("Name", new CodePrimitiveExpression(propertyName)),
                    new CodeAttributeArgument("Order", new CodePrimitiveExpression(idx))));

                p.GetStatements.Add(new CodeMethodReturnStatement(new CodeFieldReferenceExpression(
                        new CodeThisReferenceExpression(), fieldName)));
                p.SetStatements.Add(new CodeAssignStatement(new CodeFieldReferenceExpression(
                            new CodeThisReferenceExpression(), fieldName),
                            new CodePropertySetValueReferenceExpression()));

                classType.Members.Add(p);

                idx++;
            }

            // Add the type to the namespace
            codedomsamplenamespace.Types.Add(classType);

            // Add the NameSpace to the CodeCompileUnit
            compileUnit.Namespaces.Add(codedomsamplenamespace);

            return compileUnit;
        }

        private static void GenerateCode(CodeCompileUnit ccu, string fileName, CodeDomProvider codeDomProvider = null)
        {
            CompilerParameters cp = new CompilerParameters();
            String sourceFile;
            if (codeDomProvider == null)
            {
                codeDomProvider = new CSharpCodeProvider();
            }

            if (codeDomProvider.FileExtension[0] == '.')
            {
                sourceFile = fileName + codeDomProvider.FileExtension;
            }
            else
            {
                sourceFile = fileName + "." + codeDomProvider.FileExtension;
            }

            IndentedTextWriter tw1 = new IndentedTextWriter(new StreamWriter(sourceFile, false), "\t");
            codeDomProvider.GenerateCodeFromCompileUnit(ccu, tw1, new CodeGeneratorOptions());
            tw1.Close();
            //cp.GenerateExecutable = true;
            //cp.OutputAssembly = "CSharpSample.exe";
            //cp.GenerateInMemory = false;
            //cr = csharpcodeprovider.CompileAssemblyFromDom(cp, ccu);
        }

        public static Type AddDataContractAttributeToType(Type type)
        {
            string typeName = "Derived_" + type.Name;

            // create a dynamic assembly and module
            AssemblyName assemblyName = new AssemblyName();
            assemblyName.Name = "tmpAssembly";
            AssemblyBuilder assemblyBuilder = System.Threading.Thread.GetDomain().DefineDynamicAssembly(assemblyName, AssemblyBuilderAccess.Run);
            ModuleBuilder module = assemblyBuilder.DefineDynamicModule("tmpModule");

            // create a new type builder
            TypeBuilder typeBuilder = module.DefineType(typeName, TypeAttributes.Public | TypeAttributes.Class
                | TypeAttributes.Class | TypeAttributes.AutoClass | TypeAttributes.AnsiClass | TypeAttributes.BeforeFieldInit | TypeAttributes.AutoLayout,
                null, new Type[] { typeof(IEntity) });

            {
                DataContractAttribute dca = new DataContractAttribute();
                ConstructorInfo ctor = typeof(DataContractAttribute).GetConstructor(new Type[] { });
                CustomAttributeBuilder myCABuilder = new CustomAttributeBuilder(ctor, new object[] { },
                    new PropertyInfo[] { typeof(DataContractAttribute).GetProperty("Name") },
                    new object[] { typeName });
                typeBuilder.SetCustomAttribute(myCABuilder);
            }

            int idx = 0;
            // Loop over the attributes that will be used as the properties names in out new type
            foreach (PropertyInfo propertyInfo in type.GetProperties())
            {
                string propertyName = propertyInfo.Name;
                Type propertyType = propertyInfo.PropertyType;

                bool supportedType = false;

                if (propertyType.IsValueType)
                {
                    if (propertyType.IsEnum)
                    {
                        propertyType = propertyType.GetEnumUnderlyingType();
                    }
                    supportedType = true;
                }
                else if (propertyType == typeof(string))
                {
                    supportedType = true;
                }

                if (!supportedType)
                    continue;

                // Generate a private field
                FieldBuilder field = typeBuilder.DefineField("_" + propertyName, propertyType, FieldAttributes.Private);
                // Generate a public property
                PropertyBuilder property = typeBuilder.DefineProperty(propertyName, PropertyAttributes.HasDefault,
                    propertyType, null);

                // The property set and property get methods require a special set of attributes:
                MethodAttributes GetSetAttr = MethodAttributes.Public | MethodAttributes.SpecialName | MethodAttributes.HideBySig;

                // Define the "get" accessor method for current private field.
                MethodBuilder currGetPropMthdBldr = typeBuilder.DefineMethod("get_" + propertyName, GetSetAttr,
                                               propertyType, Type.EmptyTypes);

                // Intermediate Language stuff...
                ILGenerator currGetIL = currGetPropMthdBldr.GetILGenerator();
                currGetIL.Emit(OpCodes.Ldarg_0);
                currGetIL.Emit(OpCodes.Ldfld, field);
                currGetIL.Emit(OpCodes.Ret);

                // Define the "set" accessor method for current private field.
                MethodBuilder currSetPropMthdBldr = typeBuilder.DefineMethod("set_" + propertyName, GetSetAttr,
                                               null, new Type[] { propertyType });

                // Again some Intermediate Language stuff...
                ILGenerator currSetIL = currSetPropMthdBldr.GetILGenerator();
                currSetIL.Emit(OpCodes.Ldarg_0);
                currSetIL.Emit(OpCodes.Ldarg_1);
                currSetIL.Emit(OpCodes.Stfld, field);
                currSetIL.Emit(OpCodes.Ret);

                // Last, we must map the two methods created above to our PropertyBuilder to
                // their corresponding behaviors, "get" and "set" respectively.
                property.SetGetMethod(currGetPropMthdBldr);
                property.SetSetMethod(currSetPropMthdBldr);

                DataMemberAttribute dca = new DataMemberAttribute();
                ConstructorInfo ctor = typeof(DataMemberAttribute).GetConstructor(new Type[] { });
                CustomAttributeBuilder myCABuilder = new CustomAttributeBuilder(ctor, new object[] { },
                    new PropertyInfo[] { typeof(DataMemberAttribute).GetProperty("Name"), typeof(DataMemberAttribute).GetProperty("Order") },
                    new object[] { propertyName, idx });
                property.SetCustomAttribute(myCABuilder);

                idx++;
            }

            // Generate our type
            Type generetedType = typeBuilder.CreateType();

            return generetedType;
        }

        public static Type GenerateTypeFromGridColumn(string gridName)
        {
            // create a dynamic assembly and module
            AssemblyName assemblyName = new AssemblyName();
            assemblyName.Name = "tmpAssembly";
            AssemblyBuilder assemblyBuilder = System.Threading.Thread.GetDomain().DefineDynamicAssembly(assemblyName, AssemblyBuilderAccess.Run);
            ModuleBuilder module = assemblyBuilder.DefineDynamicModule("tmpModule");

            // create a new type builder
            TypeBuilder typeBuilder = module.DefineType(gridName, TypeAttributes.Public | TypeAttributes.Class
                | TypeAttributes.Class | TypeAttributes.AutoClass | TypeAttributes.AnsiClass | TypeAttributes.BeforeFieldInit | TypeAttributes.AutoLayout,
                null, new Type[] { typeof(IEntity) });

            {
                DataContractAttribute dca = new DataContractAttribute();
                ConstructorInfo ctor = typeof(DataContractAttribute).GetConstructor(new Type[] { });
                CustomAttributeBuilder myCABuilder = new CustomAttributeBuilder(ctor, new object[] { },
                    new PropertyInfo[] { typeof(DataContractAttribute).GetProperty("Name") },
                    new object[] { gridName });
                typeBuilder.SetCustomAttribute(myCABuilder);
            }

            int idx = 0;
            // Loop over the attributes that will be used as the properties names in out new type
            foreach (GridColumnInfo info in ADInfoBll.Instance.GetGridColumnInfos(gridName))
            {
                if (info.GridColumnType != GridColumnType.Normal
                    && info.GridColumnType != GridColumnType.ExpressionColumn)
                    continue;

                string propertyName = info.GridColumnName;

                Type propertyType = typeof(string);
                //Type propertyType = info.CreateType();
                //if (propertyType.IsEnum || propertyType.IsClass || info.CellViewerManager == "Combo")
                //{
                //    propertyType = typeof(string);
                //}

                //if (!propertyType.IsClass/* && Authority.AuthorizeByRule(info.NotNull)*/)
                //{
                //    propertyType = Utils.ReflectionHelper.CreateGenericType(typeof(Nullable<>), new Type[] { propertyType });
                //}

                // Generate a private field
                FieldBuilder field = typeBuilder.DefineField("_" + propertyName, propertyType, FieldAttributes.Private);
                // Generate a public property
                PropertyBuilder property = typeBuilder.DefineProperty(propertyName, PropertyAttributes.HasDefault,
                    propertyType, null);

                // The property set and property get methods require a special set of attributes:
                MethodAttributes GetSetAttr = MethodAttributes.Public | MethodAttributes.SpecialName | MethodAttributes.HideBySig;

                // Define the "get" accessor method for current private field.
                MethodBuilder currGetPropMthdBldr = typeBuilder.DefineMethod("get_" + propertyName, GetSetAttr,
                                               propertyType, Type.EmptyTypes);

                // Intermediate Language stuff...
                ILGenerator currGetIL = currGetPropMthdBldr.GetILGenerator();
                currGetIL.Emit(OpCodes.Ldarg_0);
                currGetIL.Emit(OpCodes.Ldfld, field);
                currGetIL.Emit(OpCodes.Ret);

                // Define the "set" accessor method for current private field.
                MethodBuilder currSetPropMthdBldr = typeBuilder.DefineMethod("set_" + propertyName, GetSetAttr,
                                               null, new Type[] { propertyType });

                // Again some Intermediate Language stuff...
                ILGenerator currSetIL = currSetPropMthdBldr.GetILGenerator();
                currSetIL.Emit(OpCodes.Ldarg_0);
                currSetIL.Emit(OpCodes.Ldarg_1);
                currSetIL.Emit(OpCodes.Stfld, field);
                currSetIL.Emit(OpCodes.Ret);

                // Last, we must map the two methods created above to our PropertyBuilder to
                // their corresponding behaviors, "get" and "set" respectively.
                property.SetGetMethod(currGetPropMthdBldr);
                property.SetSetMethod(currSetPropMthdBldr);

                DataMemberAttribute dca = new DataMemberAttribute();
                ConstructorInfo ctor = typeof(DataMemberAttribute).GetConstructor(new Type[] { });
                CustomAttributeBuilder myCABuilder = new CustomAttributeBuilder(ctor, new object[] { },
                    new PropertyInfo[] { typeof(DataMemberAttribute).GetProperty("Name"), typeof(DataMemberAttribute).GetProperty("Order") },
                    new object[] { propertyName, idx });
                property.SetCustomAttribute(myCABuilder);

                idx++;
            }

            // Generate our type
            Type generetedType = typeBuilder.CreateType();

            return generetedType;
        }
    }
}
